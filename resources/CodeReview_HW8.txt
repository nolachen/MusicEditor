First off, our provider’s code as a whole was well-organized and they did a good job making their view interface flexible and decoupled from the rest of their code. However, the view classes had the model interface as a field, but they said that they would only pass in a read-only implementation of the model interface. We would improve this by making a view model interface, so that a mutable model could never be passed into the view. Their views are fully functioning and capable with the HW7 specifications, but they used their mouse as buttons and didn’t use the functionality of the mouse to calculate where they were clicking. For example, you would first set the fields of a note using key presses, and if you wanted to add a note, you would just left-click on the mouse while right-clicking would delete the note. We would suggest adding some methods to the view to get information about where a mouse click was. Since they did not have this (because they implemented selecting notes solely with key presses), we couldn’t implement adding and removing notes with mouse clicks very easily. Reusing their code was fairly simple, they did a really good job of never creating instances of concrete classes like Note in their view so adapting our Note representation to their INote interface was very easy. The only suggestion we have along those lines would be to create an interface for their Pitch representation because we had to just figure out how to use theirs, which was difficult because of the lack of documentation. Another thing they did was parameterize their model over the note type which allows for a more generic model.

Ultimately, some improvements that we would recommend are to create an interface for their pitch enumeration so that clients could adapt their own, as said above. Next, we think that they should have included a default constructor in their MidiView. The code sent to us made it necessary to create a sequencer before we could create an instance of a MidiView because the only constructor required a sequencer. We just felt that sequencers should only be necessary in the MidiView class itself. This didn’t prove to be an issue because their view factory created a sequencer before creating a MidiView, but that’s something we would have tried to avoid. 

Clearly, one of the main issues we came across was lack of documentation and typos. It was clear that they rushed through a lot of their documentation and they misspelled a lot of important words relevant to their code that really confused us and we had to spend extra time figuring out what they had meant. There were a few private methods that we didn’t have any java doc for with unclear method names so we had to trace through their code to figure out what they were used for. Some of their interface documentation was very vague and just said “returns the” and then the method name. This was especially confusing when they had a getChannel method in their note interface where the documentation was “returns the channel”. Since channels are not from the Note, it took a while to figure out that they were just referring to the instrument. They also had a lot of inconsistencies that were because they weren’t careful. The readme they created had contradictions between the actual directions and the examples they gave of performing those directions. All in all, a little extra time spent would have solved these issues.

Kind is a word we would use to describe them. They were very helpful whenever we needed any changes and were quick to respond to our emails. There were no big design changes needed, they just had some code that referred to a specific class that they had not given because we didn’t need it. We had to ask them to delete the code that relied on that class for us because we weren’t allowed to do it for them.  
